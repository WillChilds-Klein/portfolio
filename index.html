<!DOCTYPE html>
<html>
<title>Will Childs-Klein</title>

<xmp theme="simplex" style="display:none;">

## Patent Trolls in the Tweetosphere [[site]][1] [[code]][2]
![](img/tweets.png)

_Patent Trolls in the Tweetosphere_ was a final project for Law, Technology, and Culture (CPSC 183) in the fall of 2014. The goal of the
project was to investigate the rise of [patent trolls](https://en.wikipedia.org/wiki/Patent_troll), using Twitter as a proxy for measuring
public awareness of their practices. The findings were divided into three twitter-related sections (mentions by year, mentions by state, and
sentiment by year) and a breakdown of patent case count by plaintiff company type for the 10 US district courts most active in patent
assertion cases. We found that Texas and California, which contain two of the three most active patent districts in the US, were also among
the three states that produced the most troll-related tweets from 2010-2014. We were also able to correlate various spikes in twitter
mentions of the phrase "patent troll" or "patent monetization entity" with prominent patent cases and their reporting in the media (e.g.
_Alice Corp. v.  CLS Bank International_ Mar. '14 - Jun. '14).

---

## GroupThink [[code]][3]

GroupThink was conceived as a decentralized, reputation-based recommendation network for altcoin mining resource allocation. Inspired by
[CryptoSwitcher](https://github.com/area/CryptoSwitcher) and Cornell's [Credence project](https://www.cs.cornell.edu/people/egs/credence/),
the general idea of GroupThink was to create a network of systems, each of which could query other nodes on the network for their expected
profitability for a particular coin `c` at a future time `t`. The querying node then stores this prediction and compares it against
`c`'s actual price at time `t`. Repeated over time and against many other nodes, a network member can construct a model of how accurate
other members' predictions are, and appropriately allocate mining resources or even adjust its own profitablity expectations
accordingly.<sup>1</sup> A partner and I attempted to build the system out as a final project for Decentralized Systems (CPSC 426) in the
fall of 2014. We got the messaging system implemented, were able to spin up small clusters of nodes, and had begun implementing a few coin
profitability models, but the scope of the project began to exceed that of a 3-week class project. Lesson learned: decentralized systems are
hard. I hope to come back to this at some point and finish implementing a prototype.

---

## Yale TrueSecret [[code]][4]
![](img/yts.png)

This was an attempt at creating an immutable, uncensored forum for discrete textual posts. The site was accessible as a [Tor hidden
service](https://www.torproject.org/docs/hidden-services.html.en), meaning that the site's host and visitors were mutually anonymous. This
was a final project for Control, Privacy, and Technology (CPSC 185), motivated by the sometimes heavy-handed moderation of a
pseudo-anonymous student message board<sup>2</sup> on Facebook. The site is no longer live due to lack of users and annoying hosting fees. A
more complete description can be found [here](https://github.com/WillChilds-Klein/cpsc185-final/blob/master/report.md).

---

## Minder [[code]][11]
![](img/minder.png)

`minder` is a simple application written in Clojure (a LISP dialect) whose sole objective is to remind the current president (and his
constituents) of his civic duties whenever his stubby little thumbs wander astray during a meeting. The application is deployed in a
"serverless" fashion on AWS Lambda. Whenever @realDonaldTrump fires off a tweet, `minder` pulls his daily schedule and checks whether the
tweet was sent during a scheduled meeting. If a conflict is detected, `minder` emits a tweet calling it out. The schedule checking logic is
exceedingly rudimentary; it considers a conflict to be any tweet sent between two scheduled meetings and within 90 minutes of the first.
This was my frist foray into learning a LISP, so the implementation is probably less than idiomatic.

---

## Bulb API [[backend code]][12] [[frontend code]][13] [[live demo]][14]

This was a curiosity-driven project meant to teach myself about designing and implementing a modern web API whereby I implemented a basic
(and generic) "RESTful" HTTP API fronted by a single-page JavaScript web client (or "SPA" as the kids are calling it these days). The
function of the "app" is arbitrary, but requirements were simple and rigid:

  1. the API should scale from one to O(10k) users with miminal developer intervention (and note empty my pockets in the process)
  1. the app should be secure and authenticated
  1. the API should be strongly consistent
  1. the app should be portable for other deployment strategies and easily extensible for futher development

The "frontend" is quite rudiemntary (really just a proof of concept), implemented in [React.js][18]. For the API, I settled on the [Flask
framework][15] in python deployed on top of [AWS Lambda][16] (orchestrated by a really [neat project called "zappa"][17]), backed by
[DynamoDB][18] as a data store. The usage of Lambda/DynamoDB satisfies 1. and 3. (both services are fully elastic), and usage of Flask/zappa
satisfies 4. (a Flask app can be deployed easily on any conventional linux machine). 2., however, was a bit more challenging. The primary
deployment mode (Lambda) required the API to work in a distributed fashion, but by default Flask uses in memory session management. So, I
had to roll my own token-based auth. The solution I eventually settled on was using filling the `Authorization` HTTP header with a signed
token with a fixed expiration timestamp. This ceded the possibility of revocation (as any signed token sent to the server before its expiry
is considered valid), but it helped drive down latency and read costs (Dynamo [charges per IO (sorta)][19]) by avoiding round-trips to the
database and obviated the need to implement distributed session management.

---

## wambam! [[site]][5] [[code]][6]
![](img/wambam.png)

wambam! was a very fun project that a team of 5 other students and I built over the course of the spring '14 semester for a Software
Engineering course (CPSC 439). The abbreviated pitch for the app can be stated as "uber for tasks". Essentially, we aimed to create a
marketplace for favors within the Yale community. A user would sign up with an email address, and either request a task or browse tasks
posted on a map to fulfill for payment. A user would request a task by dropping a pin on the app's map and enter a description of the task,
expiration date and time, pertinent locations (other than the pin drop), their contact information, and the fee they would be willing to pay for
the task's completion. Payment was facilitated by [venmo](https://venmo.com/) integration. One obvious challenge with this sort of
crowd-sourcing is protecting against bad actors. Our solution to restrict user registration to `@yale.edu` email addresses,
as emails of this domain are difficult to obtain spuriously or to counterfeit, and thus serve as a workable  proxy for trust. Had we had more
time to devote to the project, we would have liked to actually launch it (sadly, although the app was fully functional, this never happened)
and implement a counter-offer system for task prices such that task fulfillers could negotiate fair fees.

---

## BPGraph [[code]][7]

This was a project undertaken over 8 weeks under the advisement of [Ankur Mani](http://www.isye.umn.edu/faculty/Mani.shtml) in the Human
Dynamics group at the MIT Media Lab in the summer of 2013. The goal of the project was to create a step-by-step interactive visualization of
an algorithm Ankur had devised as part of his thesis work. This algorithm was a generalization of the [Hungarian
Algorithm](https://en.wikipedia.org/wiki/Hungarian_algorithm) for solving the [assignment
problem](https://en.wikipedia.org/wiki/Assignment_problem) in bipartite matching scenarios. I implemented this project in Java (the only
language I knew at the time other than C), having no real experience in web technologies. The visualization GUI was successfully
implemented, as was the most of the original Hungarian algorithm, but not enough time was left for implementing Ankur's novel contributions.
Lesson learned: Java is not at home on the web, and always allocate 2-3x as much time as you think you may need for GUI programming.

---

## Peerster [[code]][8]
![](img/peerster.png)

Built over the course of fall 2014's Decentralized Systems (CPSC 426), Peerster is a basic decentralized UDP messaging application written
in C++ with the Qt framework. Peerster communicates with other instances (Peers) via the [Gossip
Protocol](https://en.wikipedia.org/wiki/Gossip_protocol). It sports a basic graphical interface with a group chat window, direct message
window, and a text entry box, performs [NAT hole-punching](https://en.wikipedia.org/wiki/UDP_hole_punching) to subvert rudimentary
firewalls, replays message history for newly joined nodes, and even supports (searchable) bit torrent-like file sharing for decentralized
file storage.

---

## Data Mining [[code]][9] / Numerical Computation [[code]][10]

This entry is not a discrete project. The code in these repositories comprises 6 assignments over two semester-long courses. Among problems
solved by some of the assignments are the [Jacobi method](https://en.wikipedia.org/wiki/Jacobi_method) for
[finding](https://github.com/WillChilds-Klein/cpsc445/blob/master/jacobi.c) the
[SVD](https://en.wikipedia.org/wiki/Singular_value_decomposition) of a square matrix, the
[Gram-Schmidt](https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process) [method for matrix
inversion](https://github.com/WillChilds-Klein/cpsc440/blob/master/inv_double_gs.c), a nifty method for
[finding](https://github.com/WillChilds-Klein/cpsc445/blob/master/seek.c) some `k` nearest neighbors for each of `n` 2-dimentional points,
and other numerical methods. The code is all dependency-free (aside from standard system libraries) ANSI C, and can handle large input sizes
with reasonable efficiently.

---

  1. Stretch goals for the project were to replace the querying system with a blockchain to make the voting/profitability records public and
     unspoofable. The blockchain-based vote aggregation would also solve a cold-start problem with the previous implementation. Newly joined
     nodes would have to spend some time gathering expectations from others in order to form meaningful models. With the blockchain-based
     voting, all nodes' voting histories would be immediately accessible. There remains the problem of determining an incentive for mining
     voting blocks. TODO \[expand\]
  2. A Facebook group whose moderators posted the content of messages sent to the group's account, thus anonymizing the "poster" only from
     the group's readership but not its moderators. The content of this mediated model is also subject to the moderators' discretion; it
     is not a truly neutral forum for free expression.

[1]: http://will.childs-kle.in/cpsc183-final/
[2]: https://github.com/WillChilds-Klein/cpsc183-final
[3]: https://github.com/WillChilds-Klein/groupminer
[4]: https://github.com/WillChilds-Klein/cpsc185-final
[5]: http://wambam.herokuapp.com/
[6]: https://github.com/milesrichardson/wambam-cs439-spring-2014
[7]: https://github.com/WillChilds-Klein/BGraph
[8]: https://github.com/WillChilds-Klein/peerster
[9]: https://github.com/WillChilds-Klein/cpsc445
[10]: https://github.com/WillChilds-Klein/cpsc440
[11]: https://github.com/willchilds-klein/minder
[12]: https://github.com/willchilds-klein/bulb-api
[13]: https://github.com/willchilds-klein/bulb-site
[14]: https://buttaface.space
[15]: http://flask.pocoo.org
[16]: https://aws.amazon.com/lambda
[17]: https://github.com/miserlou/zappa
[18]: https://reactjs.org/
[19]: https://aws.amazon.com/dynamodb/pricing/provisioned/


</xmp>

<script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>
</html>
